# Construye una aplicaciÃ³n web usando un modelo de aprendizaje automÃ¡tico

En esta lecciÃ³n, entrenarÃ¡s un modelo de aprendizaje automÃ¡tico sobre un conjunto de datos que estÃ¡ fuera de este mundo: _avistamiento de OVNIs durante el siglo pasado_, proporcionados por la base de datos de NUFORC.

AprenderÃ¡s:

- CÃ³mo hacer 'pickle' a un modelo entrenado
- CÃ³mo usar ese modelo en una aplicaciÃ³n Flask

Continuaremos nuestro uso de notebooks para limpiar los datos y entrenar nuestro modelo, pero puedes llevar el proceso un paso mÃ¡s allÃ¡ explorando el uso de un modelo 'en la naturaleza', por asÃ­ decirlo: en una aplicaciÃ³n web.

Para hacer esto, necesitas construir una aplicaciÃ³n web usando Flask.

## [Examen previo a la lecciÃ³n](https://white-water-09ec41f0f.azurestaticapps.net/quiz/17?loc=es)

## Construyendo una aplicaciÃ³n

Existen muchas formas de construir aplicaciones web para consumir modelos de aprendizaje automÃ¡tico. Tu arquitectura web podrÃ­a influir en la forma que tu modelo es entrenado. Imagina que estÃ¡s trabajando en un negocio donde el grupo de ciencia de datos ha entrenado un modelo que quieren uses en una aplicaciÃ³n.

### Consideraciones

Hay muchas preguntas que necesitas realizar:

- **Â¿Es una aplicaciÃ³n web o mÃ³vil?** Si estÃ¡s construyendo una aplicaciÃ³n mÃ³vil o necesitas uar el modelo en un contexto de IoT, podrÃ­as usar [TensorFlow Lite](https://www.tensorflow.org/lite/) y usar el modelo en una applicaciÃ³n Android o iOS.
- **Â¿DÃ³nde residirÃ¡ el modelo?** Â¿En la nube o de forma local?
- **Soporte fuera de lÃ­nea.** Â¿La aplicaciÃ³n trabaja en modo fuera de lÃ­nea?
- **Â¿QuÃ© tecnologÃ­a se usÃ³ para entrenar al modelo?** La tecnologÃ­a elegida puede influir en las herramientas que necesitas utilizar.
    - **Uso de TensorFlow.** Si estÃ¡s entrenando un modelo usando TensorFlow, por ejemplo, ese ecosistema proporciona la capacidad de convertir un modelo de TensorFlow para su uso en una aplicaciÃ³n web usando [TensorFlow.js](https://www.tensorflow.org/js/).
    - **Uso de PyTorch.** Si estÃ¡s construyendo un modelo usando una librerÃ­a como [PyTorch](https://pytorch.org/), tienes la opciÃ³n de exportarlo en formato [ONNX](https://onnx.ai/) (Open Neural Network Exchange) para usarlo en aplicaciones web de javascript que puedan usar el entorno de ejecuciÃ³n [Onnx Runtime](https://www.onnxruntime.ai/). Esta opciÃ³n serÃ¡ explorada en una futura lecciÃ³n para un modelo entrenado Scikit-learn.
    - **Uso de Lobe.ai o Azure Custom Vision.** Si estÃ¡s usando un sistema de aprendizaje automÃ¡tico SaaS (Software as a Service) como lo es [Lobe.ai](https://lobe.ai/) o [Azure Custom Vision](https://azure.microsoft.com/services/cognitive-services/custom-vision-service/?WT.mc_id=academic-15963-cxa) para entrenar un modelo, este tipo de software proporciona formas de exportar el modelo a diversas plataformas, incluyendo el construir una API a medida para que esta sea consultada en la nube por tu aplicaciÃ³n en lÃ­nea.

TambiÃ©n tienes la oportunidad de construir una plicaciÃ³n web completamente en Flask que serÃ¡ capaz de entrenar el propio modelo en un navegador web. Esto tambiÃ©n puede ser realizado usando TensorFlow.js en un contexto JavaScript.

Para nuestros propÃ³sitos, ya que hemos estado trabajando con notebooks basados en Python, exploremos los pasos que necesitas realizar para exportar un modelo entrenado desde un notebook a un formato legible para una aplicaciÃ³n web construida en Python.

## Herramientas

Para esta tarea, necesitas dos herramientas: Flask y Pickle, ambos corren en Python.

âœ… Â¿QuÃ© es [Flask](https://palletsprojects.com/p/flask/)? Definido como un 'micro-framework' por sus creadores, Flask proporciona las caracterÃ­sticas bÃ¡sicas de los frameworks web usando Python y un motor de plantillas para construir pÃ¡ginas web. Da un vistazo a [este mÃ³dulo de aprendizaje](https://docs.microsoft.com/learn/modules/python-flask-build-ai-web-app?WT.mc_id=academic-15963-cxa) para practicar construir con Flask.

âœ… Â¿QuÃ© es [Pickle](https://docs.python.org/3/library/pickle.html)? Pickle ðŸ¥’ es un mÃ³dulo de Python que serializa y deserializa estructura de objetos Python. Cuando conviertes un modelo en 'pickle', serializas o aplanas su estructura para su uso en la web. SÃ© cuidadoso: Pickle no es intrÃ­nsecamente seguro, por lo que debes ser cuidadoso si solicitaste hacer 'un-pickle' en un archivo. Un archivo hecho pickle tiene el sufijo `.pkl`.

## Ejercicio - limpia tus datos

En esta lecciÃ³n usarÃ¡s datos de 80,000 avistamientos de OVNIs, recopilados por [NUFORC](https://nuforc.org) (El centro nacional de informes OVNI). Estos datos tienen algunas descripciones interesantes de avistamientos OVNI, por ejemplo:


- **DescripciÃ³n larga del ejemplo.** "Un hombre emerge de un haz de luz que brilla en un campo de hierba por la noche y corre hacia el estacionamiento de Texas Instruments".
- **DescripciÃ³n corta del ejemplo.** "las luces nos persiguieron".

La hoja de cÃ¡lculo [ufos.csv](../data/ufos.csv) incluye columnas acerca de los campos `city`, `state` y `country` donde ocurriÃ³ el avistamiento, la forma (`shape`) y su latitud (`latitude`) y ubicaciÃ³n (`latitude` y `longitude`).

En el [notebook](../notebook.ipynb) en blanco incluÃ­do en esta lecciÃ³n:

1. Importa `pandas`, `matplotlib`, y `numpy` como lo hiciste en lecciones anteriores e importa la hoja de cÃ¡lculo ufos. Puedes dar un vistazo al conjunto de datos de ejemplo:

    ```python
    import pandas as pd
    import numpy as np
    
    ufos = pd.read_csv('./data/ufos.csv')
    ufos.head()
    ```

1. Convierte los datos de OVNIs en un pequeÃ±o dataframe con nuevos tÃ­tulos. Revisa los valores Ãºnicos en el campo `Country`.

    ```python
    ufos = pd.DataFrame({'Seconds': ufos['duration (seconds)'], 'Country': ufos['country'],'Latitude': ufos['latitude'],'Longitude': ufos['longitude']})
    
    ufos.Country.unique()
    ```

1. Ahora, puedes reducir la cantidad de datos que necesitamos manejar eliminando cualquier valor nulo e importando Ãºnicamente los avistamientos entre 1 y 60 segundos:

    ```python
    ufos.dropna(inplace=True)
    
    ufos = ufos[(ufos['Seconds'] >= 1) & (ufos['Seconds'] <= 60)]
    
    ufos.info()
    ```

1. Importa la librerÃ­a `LabelEncoder` de Scikit-learn para convertir los valores de texto de los paÃ­ses a nÃºmero:

    âœ… LabelEncoder codifica los datos alfabÃ©ticamente

    ```python
    from sklearn.preprocessing import LabelEncoder
    
    ufos['Country'] = LabelEncoder().fit_transform(ufos['Country'])
    
    ufos.head()
    ```

    Tus datos deberÃ­an verse asÃ­:

    ```output
    	Seconds	Country	Latitude	Longitude
    2	20.0	3		53.200000	-2.916667
    3	20.0	4		28.978333	-96.645833
    14	30.0	4		35.823889	-80.253611
    23	60.0	4		45.582778	-122.352222
    24	3.0		3		51.783333	-0.783333
    ```

## Ejercicio - construye tu modelo

Ahora puedes prepararte para entrenar un modelo dividiendo los datos entre los grupos de entrenamiento y pruebas.

1. Selecciona las tres caracterÃ­sticas que quieres entrenar en tu vector X, y el vector Y serÃ¡ `Country`. Quieres ser capaz de introducir `Seconds`, `Latitude` y `Longitude` y obtener un id de paÃ­s de regreso.

    ```python
    from sklearn.model_selection import train_test_split
    
    Selected_features = ['Seconds','Latitude','Longitude']
    
    X = ufos[Selected_features]
    y = ufos['Country']
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
    ```

1. Entrena tu modelo usando regresiÃ³n logÃ­stica:

    ```python
    from sklearn.metrics import accuracy_score, classification_report
    from sklearn.linear_model import LogisticRegression
    model = LogisticRegression()
    model.fit(X_train, y_train)
    predictions = model.predict(X_test)
    
    print(classification_report(y_test, predictions))
    print('Predicted labels: ', predictions)
    print('Accuracy: ', accuracy_score(y_test, predictions))
    ```

La precisiÃ³n no es mala **(alrededor del 95%)**, como era de esperar, ya que `Country` y `Latitude/Longitude` se correlacionan.

El modelo que creaste no es muy revolucionario como deberÃ­as ser capaz de inferir un paÃ­s (`Country`) por su latitud y longitud (`Latitude`, `Longitude`), pero es un buen ejercicio intentar entrenar desde datos en crudo que ya limpiaste, exportaste y luego usa este modelo en una aplicaciÃ³n web.

## Ejercicio - Haz 'pickle' a tu modelo

Ahora, Â¡es momento de hacer _pickle_ a tu modelo! Puedes hacer eso con pocas lÃ­neas de cÃ³digo. Una vez la hiciste _pickle_, carga tu modelo serializado (pickled) y pruÃ©balo constra un arreglo de datos de muestra que contenga los valores para segundos, latitud y longitud.

```python
import pickle
model_filename = 'ufo-model.pkl'
pickle.dump(model, open(model_filename,'wb'))

model = pickle.load(open('ufo-model.pkl','rb'))
print(model.predict([[50,44,-12]]))
```

El modelo regresa **'3'**, lo cual es el cÃ³digo de paÃ­s para el Reino Unido (UK). Â¡Sorprendente! ðŸ‘½

## Ejercicio - Construye una aplicaciÃ³n Flask

Ahora puedes construir una aplicaciÃ³n Flask para llamara tu modelo y regresar resultados similares, pero de una forma visualmente mÃ¡s agradable.

1. Comienza por crear un directorio llamado **web-app** junto al archivo _notebook.ipynb_  donde reside el archivo _ufo-model.pkl_.

1. En ese directorio crea 3 directorios mÃ¡s: **static**, con un directorio **css** dentro de el, y **templates**.  Ahora tienes la siguiente estructura de directorios:

    ```output
    web-app/
      static/
        css/
      templates/
    notebook.ipynb
    ufo-model.pkl
    ```

    âœ… Consulta el directorio de la soluciÃ³n para una vista de la aplicaciÃ³n terminada.

1. El primer archivo a crear en el directorio _web-app_ es el archivo **requirements.txt**. AsÃ­ como _package.json_ en una aplicaciÃ³n JavaScript, este archivo lista las dependencias requeridas por la aplicaciÃ³n. En **requirements.txt** agrega las lÃ­neas:

    ```text
    scikit-learn
    pandas
    numpy
    flask
    ```

1. Ahora, ejecuta este archivo navegando a _web-app_:

    ```bash
    cd web-app
    ```

1. Escribe en tu terminal `pip install`, para instalar las librerÃ­as listadas en _requirements.txt_:

    ```bash
    pip install -r requirements.txt
    ```

1. Ahora, estÃ¡s listo para crear 3 archivos mÃ¡s y asÃ­ terminar la aplicaciÃ³n:

    1. Crea el archivo **app.py** en la raÃ­z.
    2. Crea el archivo **index.html** dentro del directorio _templates_.
    3. Crea el archivo **styles.css** dentro del directorio _static/css_.

1. Construye el archivo _styles.css_ file con algunos estilos:

    ```css
    body {
    	width: 100%;
    	height: 100%;
    	font-family: 'Helvetica';
    	background: black;
    	color: #fff;
    	text-align: center;
    	letter-spacing: 1.4px;
    	font-size: 30px;
    }
    
    input {
    	min-width: 150px;
    }
    
    .grid {
    	width: 300px;
    	border: 1px solid #2d2d2d;
    	display: grid;
    	justify-content: center;
    	margin: 20px auto;
    }
    
    .box {
    	color: #fff;
    	background: #2d2d2d;
    	padding: 12px;
    	display: inline-block;
    }
    ```

1. Lo siguiente es constuir el archivo _index.html_:

    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>ðŸ›¸ UFO Appearance Prediction! ðŸ‘½</title>
        <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
      </head>
    
      <body>
        <div class="grid">
    
          <div class="box">
    
            <p>According to the number of seconds, latitude and longitude, which country is likely to have reported seeing a UFO?</p>
    
            <form action="{{ url_for('predict')}}" method="post">
              <input type="number" name="seconds" placeholder="Seconds" required="required" min="0" max="60" />
              <input type="text" name="latitude" placeholder="Latitude" required="required" />
              <input type="text" name="longitude" placeholder="Longitude" required="required" />
              <button type="submit" class="btn">Predict country where the UFO is seen</button>
            </form>
    
            <p>{{ prediction_text }}</p>
    
          </div>
    
        </div>
    
      </body>
    </html>
    ```

    Echa un vistazo a la plantilla en este archivo. Nota la sitaxis 'mustache' alrededor de las variables que serÃ¡n proporcionadas por la aplicaciÃ³n, como el texto de predicciÃ³n `{{}}`. TambiÃ©n hay un formulario que publica una predicciÃ³n a la ruta `/predict`.

    Finalmente, estÃ¡s listo para construir el archivo python que maneja el consumo de el modelo y la pantalla de predicciones:

1. En `app.py` agrega:

    ```python
    import numpy as np
    from flask import Flask, request, render_template
    import pickle
    
    app = Flask(__name__)
    
    model = pickle.load(open("./ufo-model.pkl", "rb"))
    
    
    @app.route("/")
    def home():
        return render_template("index.html")
    
    
    @app.route("/predict", methods=["POST"])
    def predict():
    
        int_features = [int(x) for x in request.form.values()]
        final_features = [np.array(int_features)]
        prediction = model.predict(final_features)
    
        output = prediction[0]
    
        countries = ["Australia", "Canada", "Germany", "UK", "US"]
    
        return render_template(
            "index.html", prediction_text="Likely country: {}".format(countries[output])
        )
    
    
    if __name__ == "__main__":
        app.run(debug=True)
    ```

    > ðŸ’¡ Tip: Cuando agregas [`debug=True`](https://www.askpython.com/python-modules/flask/flask-debug-mode) mientras ejecutas la aplicaciÃ³n web usando Flask, cualquier cambio que realices a tu aplicaciÃ³n serÃ¡ reflejado inmediatamente sin la necesidad de reiniciar el servidor. Â¡Ten cuidado! No actives este modo en una aplicaciÃ³n en producciÃ³n.

Si ejecutas `python app.py` o `python3 app.py` - tu servidor web inicia, localmente, y puedes llenar un pequeÃ±o formulario para obtener una respuesta a tu pregunta en cuestiÃ³n acerca de Â¡dÃ³nde han avistado OVNIs!

Antes de hacerlo, echa un vistazo a las partes de `app.py`:

1. Primero, las dependencias son cargadas y la aplicaciÃ³n inicia.
2. Luego, el modelo es importado.
3. Lo siguiente, el archivo index.html es renderizado en la ruta principal.

En la ruta `/predict`, pasan muchas cosas cuando el formulario se publica:

1. Las variables del formulario son reunidas y convertidas a un arreglo de numpy. Luego estas son enviadas al modelo y se regresa una predicciÃ³n.
2. Los paÃ­ses que queremos se muestren son re-renderizados como texto legible de su cÃ³digo de paÃ­s previsto, y ese valor es enviado de vuelta a index.html para ser renderizado en la plantilla.

Usando un modelo de esta forma, con Flask y un modelo hecho pickled, es relativamente sencillo. La cosa mÃ¡s difÃ­cil es entender quÃ© forma tienen los datos que deben ser enviados al modelo para obtener una predicciÃ³n. Todo eso depende en cÃ³mo fue entrenado el modelo. Este tiene 3 puntos de datos como entrada para asÃ­ obtener una predicciÃ³n.

En un entorno profesional, puedes ver cÃ³mo la buena comunicaciÃ³n es necesaria entre las personas las cuales entrenan el modelo y aquellas que lo consumen en una aplicaciÃ³n web o mÃ³vil. En nuestro caso, es una sola persona, Â¡tÃº!

---

## ðŸš€ DesafÃ­o

En lugar de trabajar en un notebook e importar el modelo a una aplicaciÃ³n Flask, Â¡podrÃ­as entrenar el modelo directo en la aplicaciÃ³n Flask! Intenta convertir tu cÃ³digo Python en el notebook, quizÃ¡ despuÃ©s que tus datos sean limpiados, para entrenar el modelo desde la aplicaciÃ³n en una ruta llamada `train`. Â¿CuÃ¡les son los pros y contras de seguir este mÃ©todo?

## [Examen posterior a la lecciÃ³n](https://white-water-09ec41f0f.azurestaticapps.net/quiz/18?loc=es)

## RevisiÃ³n y autoestudio

Hay muchas formas de construir una aplicaciÃ³n web para consumir modelos de aprendizaje automÃ¡tico. Haz una lista de las formas en que podrÃ­as usar JavaScript o Python para construir una aplicaciÃ³n web para aprovechar el apredizaje automÃ¡tico. Considera la arquitectura: Â¿El modelo deberÃ­a estar en la aplicaciÃ³n o vivir en la nube? Si es lo segundo, Â¿CÃ³mo lo accederÃ­as? Dibuja un modelo de arquitectura para una soluciÃ³n web de aprendizaje automÃ¡tico aplicada.

## AsignaciÃ³n

[Prueba un modelo diferente](assignment.es.md)
